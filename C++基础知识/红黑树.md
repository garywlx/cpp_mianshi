## 红黑树

### 红黑树

https://www.cnblogs.com/sgatbl/p/9484097.html

红黑树(Red-Black Tree，简称R-B Tree)。

红黑树是一种特殊的平衡二叉树（AVL），可以保证在最坏的情况下，基本动态集合操作的时间复杂度为O(logn)。因此，被广泛应用于企业级的开发中。

红黑树的出现是为了解决二叉平衡树频繁的插入和删除导致的性能降低的问题。

红黑树查找的最坏时间复杂度为O(logN)。
不过与二叉平衡树不同的是：红黑树的插入与删除不会像二叉平衡树那样频繁的破坏红黑树的规则，从而不需要进行频繁的调整。

##### 平衡二叉树

二叉平衡树的出现就是为了解决二叉搜索树退化成链表的情况，二叉平衡树的特点：具有二叉搜索树的特点，而且每个结点的左子树与右子树的高度差不超过 1

所以二叉平衡树的最坏时间复杂度为O(log2N)。

在插入元素的过程中不断使用左旋、右旋、先左旋再右旋、先右旋再左旋等操作来满足二叉平衡树的性质（每个结点的左子树与右子树的高度差不超过 1）。

但是二叉平衡树的要求太严格，若出现频繁的插入、删除操作对二叉平衡树的性能会大打折扣，为了避免这种情况的发生，又引申出了**红黑树**

##### 二叉搜索树

二叉搜索树的特点是：左子树的结点值比根结点值小，右子树的结点值比根结点小

在查找的过程中，是采用二分查找的思想，在正常情况下，查找的时间复杂度是O(log2N)，但是有一种极端情况，就是此时的二叉树是单支树，此时，查找的时间复杂度为O(N)，为了避免这种情况的发生，我们引申出了**二叉平衡树**（AVL树）

##### 红黑树的性质

​		在一棵红黑树中，其每个结点上增加了一个存储位（属性color）来表示结点的颜色，且颜色只能是red or black。通过对任何一条从根到叶子的简单路径上各个结点的颜色进行约束，红黑树确保没有一条路径会比其他路径长出2倍，因而是近似于平衡的。

　　树中每个结点包含5个属性：color、val、lchild、rchild和p（可选）。如果一个结点没有子结点或父结点，则该结点相应指针属性的值为NIL。我们可以把这些NIL视为指向二叉搜索树的叶结点（外部结点）的指针，而把带关键字的结点视为树的内部结点。

　　一棵红黑树是满足下面红黑性质的二叉搜索树：

性质1. 节点是红色或黑色。

性质2. 根是黑色。

性质3. 所有叶子都是黑色（叶子是NIL节点）。

性质4. 每个红色节点的两个子节点都是黑色。(从每个叶子到根的所有路径上不能有两个连续的红色节点)

性质5. 从任一节点到其每个叶子(NIL节点)的所有简单路径都包含相同数目的黑色节点。

 



![image-20200803214707804](C:\Users\xuyingfeng\AppData\Roaming\Typora\typora-user-images\image-20200803214707804.png)

　　为了便于处理红黑树代码中的边界条件，使用一个哨兵来代表NIL。对于一棵红黑树tree，哨兵NIL是与一个与树中普通结点有相同属性的对象。它的color属性为black，其他属性可以为任意值。

这些约束强制了红黑树的关键性质: 从根到叶子的最长的可能路径不多于最短的可能路径的两倍长。结果是这个树大致上是平衡的。因为操作比如插入、删除和查找某个值的最坏情况时间都要求与树的高度成比例，这个在高度上的理论上限允许红黑树在最坏情况下都是高效的，而不同于普通的二叉查找树。

要知道为什么这些特性确保了这个结果，注意到属性4导致了路径不能有两个毗连的红色节点就足够了。最短的可能路径都是黑色节点，最长的可能路径有交替的红色和黑色节点。因为根据属性5所有最长的路径都有相同数目的黑色节点，这就表明了没有路径能多于任何其他路径的两倍长。

从红黑树中任一结点x出发（不包括结点x），到达一个外部结点的任一路径上的黑结点个数叫做结点x的黑高度，亦称为结点的阶（rank），记作bh（x）。红黑树的黑高度定义为其根结点的黑高度。下图，数字表示该结点的黑高度。

![img](https://img2018.cnblogs.com/blog/1475571/201905/1475571-20190520130304990-742271583.png)

##### 旋转

​		在一棵含有n个关键字的红黑树上，进行插入和删除操作，需要的时间复杂度为O(logn)，由于这两个操作，会导致插入和删除后的树不满足红黑树的性质。为了维护这些性质，需要改变树中某些结点的颜色以及指针结构。

　　指针结构的修改是通过旋转来完成的，这是一种能保持二叉搜索树性质的搜索树局部操作，旋转分为左旋和右旋。如下图所示：

![img](https://images2018.cnblogs.com/blog/1128337/201808/1128337-20180815202350670-1230252504.png)

```cpp
//左旋
template<typename T>
void RedBlackTree<T>::LeftRotation(RedBlackNode<T>* &t){
    RedBlackNode<T> *temp = t->rchild;
    t->rchild = temp->lchild;
    if(Parent(t)==NIL){
        root = temp;
    }
    temp->lchild = t;
    Parent(t)->rchild = temp;
}
//右旋
template<typename T>
void RedBlackTree<T>::RightRotation(RedBlackNode<T>* &t){
    RedBlackNode<T> *temp = t->lchild;
    t->lchild = temp->rchild;
    if(Parent(t)==NIL){
        root = temp;
    }
    temp->rchild = t;
    Parent(t)->lchild = temp;
}
```

##### 红黑树的插入操作

​		前面说过，在一棵含有n个关键字的红黑树上，执行插入操作，需要时间复杂度为O(logn)。为了做到这一点，需要往原红黑树中插入一个红色的结点。那么问题来了，为什么插入的是红色结点，而不是黑色结点呢？我们知道，红黑树有五个性质，如果插入红色结点，则可能会违反性质4，而如果是插入黑色结点，则一定会违反性质5。也就是说，插入红色结点比插入黑色结点更不容易违反红黑树的性质，而违反性质条数越多，相应的要做的调整操作也就越多，导致算法的时间复杂度也就越高，从而影响算法的执行速度。

对于一棵红黑树来说，插入一个红色结点，主要有六种情况，其中三种与另外三种是对称的。这一点取决于插入结点 z 的父亲结点是插入结点的祖父结点的左孩子还是右孩子。

　　下面给出两种对称下，所对应的三种情况：

- case1：插入结点 z 的叔结点 y 是红色的。

![img](https://images2018.cnblogs.com/blog/1128337/201808/1128337-20180815211238258-2003564970.png)

图显示了该情况的情形，这种情况实在插入结点z的父结点z.p和其叔结点y都是红色时发生的。因为插入结点z的祖父结点z.p.p是黑色的，所以将z.p和y都着为黑色，来解决z和z.p都是红色的问题，而由于性质5的要求，如果只是把z.p和y的颜色改为黑色，则会破坏该性质，因此需要对z.p.p结点的颜色进行调整，以保证性质5的满足。

但是，性质1调整以后，就一定能维持红黑树的性质吗？我们以z表示新插入的结点，z'表示经过此次操作后的结点，由上述操作可以知道，z'=z.p.p。则经过此次操作后，有以下结果：

- - 　因为这次操作把z.p.p着为红色，结点z'在下次操作的开始是红色的。
  -   在这次操作中结点z'.p是z.p.p.p，且这个结点的颜色不会改变。如果它是根结点，则在此次迭代之前它是黑色的，且它在下次操作的开头任然是黑色的。
  - 　我们也知道，case1保持性质5，而且它也不会引起性质1或性质3的破坏。

　　如果结点z'在下一次操作开始时是根结点，则在这次操作中case1修正了唯一被破坏的性质4。由于z'是红色的而且是根结点，所以性质2成为唯一被违反的性质，这是由z'导致的。

　　如果结点z'在下一次操作开始时不是根结点，则case1不会导致性质2被破坏，case1修正了在这次操作的开始唯一违反的性质4。然后把z’着色为红色而z'.p不变，因此，如果z'.p是黑色的，则没有违反性质4，若是z'.p是红色的，则违反了性质4。

- case2：插入结点 z 的叔结点 y 是黑色的且 z 是一个右孩子。

- case3：插入结点 z 的叔结点 y 是黑色的且 z 是一个左孩子。

　　在case2和case3中，z的叔结点是黑色的。通过z是z.p的右孩子还是左孩子来区别这两种情况（叔结点都是黑色，无法在逻辑上进行区别）。对于这两种情况，如下图所示：

![img](https://images2018.cnblogs.com/blog/1128337/201808/1128337-20180816003712691-813188779.png)

　　　　　　左图为case2，右图为case3

　　我们发现case2与case3存在某种指针结构上的关系，很明显二者之间可以通过左旋和右旋操作进行相互转换。由于z和z.p都是红色的，因此，旋转操作对树的黑高和性质5都无影响。无论怎么进入哪两种情况，y总是黑色的，否则就要执行case1对应的操作。此外，这种旋转操作，有个好处是，并不改变旋转后，z的身份，尽管会导致z的左右孩子身份改变了，但依旧是z.p的孩子。在case3中，我们可以通过改变某些结点的颜色，并作一次右旋，就能保证性质5。这样，由于在一行中不会再存在有两个红色结点，因此，保证了红黑树的性质，所有的处理也到此完毕了。如下所示：

![img](https://images2018.cnblogs.com/blog/1128337/201808/1128337-20180816005734967-585173306.png)

　　可以看到，case2和case3的操作，会最终使得插入结点后的树，维持红黑树的性质。由此，不禁怀疑，这样的操作能完全保证吗？答案是肯定的。下面来证明：

- case2让z指向红色的z.p。在case2和case3中，z或z的颜色都不会改变，所以，在由case2转为case3后，这并不会产生其他性质的改变。
- case3把z.p着成黑色，使得如果z.p在下一次操作开始时是根结点，则它是黑色的。
- 和case1一样，红黑树的性质1、3、5都在case2和case3中得以保持。

　　由于结点z在case2和case3中都不是根结点，因此，性质2未被破坏，这两种情况因此也不会引起性质2的违反。由此，证明了z.p为z.p.p的左孩子时候，对插入z后的红黑树，按照上述调整，可以做到恢复红黑树的性质。而当z.p为z.p.p的右孩子时，由于与前面一大情况是对称的，因此，通过修改left和right的对应，就可实现。而完全实现树的回复，可以通过while循环来保持。以下是实现树的插入的代码：

```cpp
template<typename T>
bool RedBlackTree<T>::Insert(T e){
    RedBlackNode<T> *p, *f;
    p = f = NULL;

    if(!searchBST(root, p, e, f)){//not found, need to create, p points to the last node.

        RedBlackNode<T> *s = createNewNode(e);
        if(root==NULL){
            root = s;
            root->color = "black";
        }
        else{
            if(e<p->val){
                p->lchild = s;
            }
            else{
                p->rchild = s;
            }
            if(p->color == "red"){//double red node, need to adjust
                adjustDoubleRed(s, p);
            }
        }
        return true;
    }
    else{//node exists. return false
        return false;
    }
}

template<typename T>
RedBlackNode<T>* RedBlackTree<T>::Parent(RedBlackNode<T>* &t)const{
    /*
    *@Parameter:
    *q: a queue to save rb-node.
    *t: a point which points to a node in the RBTree.
    *father: a point which points to the father node of t.
    */
    queue<RedBlackNode<T>*> q;
    RedBlackNode<T>* father;
    if(root!=NULL){
        q.push(root);
        while(!q.empty()){//BFSTraverse to find the father node of t.
            father = q.front();
            q.pop();
            if((father->lchild!=NIL&&father->lchild==t)||(father->rchild!=NIL&&father->rchild==t)){
                return father;
            }
            else{
                if(father->lchild!=NIL){
                    q.push(father->lchild);
                }
                if(father->rchild!=NIL){
                    q.push(father->rchild);
                }
            }
        }
    }
    return NIL;        //not found, return NIL
}

template<typename T>
bool RedBlackTree<T>::searchBST(RedBlackNode<T>* &t, RedBlackNode<T>* &p, T &e, RedBlackNode<T>* f)const{
    //在树中t中递归地查找其值等于e的数据，若查找成功，则指针p指向该数据
    //结点，并返回true，否则指针p指向查找路径上访问的最后一个结点以便插入
    //并返回false，指针f指向p的双亲，其初始调用值为NULL。Insert()调用
    if(t==NULL||t==NIL){
        p = f;
        return false;
    }
    if(e==t->val){
        p = t;
        return true;
    }
    else if(e<t->val){
        return searchBST(t->lchild, p, e, t);
    }
    else{
        return searchBST(t->rchild, p, e, t);
    }
}

template<typename T>
void RedBlackTree<T>::LeftRotation(RedBlackNode<T>* &t){
    RedBlackNode<T> *temp = t->rchild;
    t->rchild = temp->lchild;
    if(Parent(t)==NIL){
        root = temp;
    }
    temp->lchild = t;
    Parent(t)->rchild = temp;
}

template<typename T>
void RedBlackTree<T>::RightRotation(RedBlackNode<T>* &t){
    RedBlackNode<T> *temp = t->lchild;
    t->lchild = temp->rchild;
    if(Parent(t)==NIL){
        root = temp;
    }
    temp->rchild = t;
    Parent(t)->lchild = temp;
}

template<typename T>
void RedBlackTree<T>::adjustDoubleRed(RedBlackNode<T>* &s, RedBlackNode<T>* &p){
    /*
    *@Parameter:
    *s: rb-node.
    *p: the father node of s.
    */
    RedBlackNode<T> *y, *gp;
    while(p->color=="red"){
        gp = Parent(p);
        if(p==gp->lchild){
            y = gp->rchild;
            if(y->color=="red"){//case 1
                p->color = "black";
                y->color = "black";
                gp->color = "red";
                s = gp;
                p = Parent(s);
            }
            else if(s==p->rchild){//case 2
                s = p;
                LeftRotation(p);
            }
            else{
                p->color = "black";
                gp->color = "red";
                RightRotation(gp);
            }
        }
        else{
            y = gp->lchild;
            if(y->color=="red"){//case 1
                p->color = "black";
                y->color = "black";
                gp->color = "red";
                s = gp;
                p = Parent(s);
            }
            else if(s==p->lchild){//case 2
                s = p;
                RightRotation(s);
            }
            else{
                p->color = "black";
                gp->color = "red";
                LeftRotation(gp);
            }
        }
    }
    root->color = "black";
}
```

#####  红黑树的删除操作

由于红黑树与BST树相似，因此，其删除操作与BST树在逻辑上是基本一致的，唯一的区别在于，红黑树需要对删除结点后的树进行调整，使其符合红黑树的性质。对于一棵红黑树来说，如果先不考虑结点的颜色，删除一个结点无非是三种情况，这一点与BST树是一致的，即：

- 被删除结点没有左右子结点；
- 被删除结点仅有一个子节点（左或右都有可能）；
- 被删除结点左右子结点都存在；

　　根据上述三种情况，可以编写出BST树的删除结点操作的代码，下面给出BST树的删除操作示意图：

![img](https://images2018.cnblogs.com/blog/1128337/201808/1128337-20180818202545672-351209959.png)

![img](https://images2018.cnblogs.com/blog/1128337/201808/1128337-20180818202605104-203599723.png)

![img](https://images2018.cnblogs.com/blog/1128337/201808/1128337-20180818202637857-275968519.png)

​		很明显，红黑树在结点的结构上，也是符合上述形式的，即左<根<右，因此，红黑树的删除操作是从BST输的删除操作的基础上，修改得到的，为什么需要修改呢？就是因为红黑树的每个结点具有红黑属性。

　　由于红黑属性的影响，导致，删除结点后红黑树将不符合红黑树原有的特性，我们知道，删除某个结点，按照上述调整，将会使得被删除结点所在的子树不符合原红黑树的特性1、2、4或5（非删除结点不受影响）。因此，只需要对子树进行颜色调整，就能使红黑树性质保持不变。

##### 伪码中Transplant函数的实现

如何删除的原理已经讲明白了，那么我们看，两个结点是如何替换（也就是发生删除操作的）。

![img](https://images2018.cnblogs.com/blog/1128337/201808/1128337-20180821011326076-836508461.png)

在伪码中，结点u为被替换结点，你可以理解为，被删除结点，而v是用来替换被删除结点的结点（通常为u的子节点或者u的右子树结点的最小节点）。

　　下面是我实现的transplant函数：

```cpp
template<typename T>
void RedBlackTree<T>::Transplant(RedBlackNode<T>* &u, RedBlackNode<T>* &v){
    /*
    *a function to achieve node u is replaced by v.
    *@Parameter:
    *u: a node which is replaced by v.
    *v: a node wants to replace u.
    */
    if(Parent(u) == NIL){//待删除结点为根结点.
        root = v;
    }
    else if(u==Parent(u)->lchild){
        Parent(u)->lchild = v;
    }
    else{
        Parent(u)->rchild = v;
    }
}
```

#####  红黑树删除操作的具体实现

<img src="https://images2018.cnblogs.com/blog/1128337/201808/1128337-20180820195636675-443926467.png" alt="img" style="zoom: 67%;" />

上述代码中，结点z为删除结点，y为指向结点z的指针。我们知道，BST的删除操作是很容易实现的，对于红黑树来说，关键在于，删除操作以后，什么情况下，会破坏红黑树的红黑性质。

　　由于y的颜色有可能发生改变（因为根据代码，y始终指向树结构中被删除结点的位置），用变量y_original_color存储了发生改变前的y位置的颜色。第2行和第10行在给y赋值之后，立即设置该变量。当z有两个子结点时，则y！=z且结点y移至红黑树中结点z的原始位置；第20行给y赋予和z一样的颜色。然后保存y的原始颜色，以在删除操作结束时，测试它；如果它是黑色的，那么删除或移动y会引起红黑性质的破坏，为什么会是黑色引起红黑性质的破坏呢？

- 　　对于情况1，即不存在子结点的被删除结点来说，什么情况下删除该结点以后会改变原有红黑树的性质呢？很显然，被删除结点是黑色的时候，删除它会违背红黑树的性质5，而被删除结点为红色的时候，删除它并不会影响红黑树的性质，直接修改即可（如下所示），在这里，就产生了删除结点后，后续修改颜色的第一种情况。

![img](https://images2018.cnblogs.com/blog/1128337/201808/1128337-20180818220537673-1332413308.png)

　　如上图所示，如果删除结点5，对于左侧的树，如果删除结点y，则结点7不会违反任何红黑树的性质，因为结点y的子结点为必定为黑色（由于红黑树的性质），因此，y为红色不会引起红黑树性质的改变；对于右侧的树，如果删除结点y，则如果结点y的子结点为NIL（黑色），不会引起结点7与结点y子结点之间都为红色，从而不违反了红黑树的性质。

- 　　对于情况2，即存在左结点或者右结点，由于红黑树结点存在color属性，因此，常见的做法是将用来替换删除结点的结点的颜色改成与删除结点颜色一致，这样，只需要对修改过指针结构后的子树进行修改其颜色，即可完成红黑树性质的保持。那么，由于颜色的存在，又会有那些情况的出现呢？我们知道，一个结点无非是红色或者黑色，且根据性质，红结点的子结点颜色必为黑色，那么，以被删除结点为左结点为例，有下面两种情况：

 　![img](https://images2018.cnblogs.com/blog/1128337/201808/1128337-20180818232833674-2010513680.png)

　　从左边的红黑树来看，如果待删除结点颜色为黑色，当对该结点进行操作时，则由于，其子结点为红色，与y结点的父结点同为红色，因此，会违背红黑树的性质，而如果是右边的情况，则不会，因为删除结点y以后，由于结点4依旧为黑色，不会破坏红黑树的性质。对于这种情况下，左子树结点不存在而右子树结点存在的情况，也是同样的道理，读者可以自己画图思考一下。

 

- 　　对于情况3，即被删除结点同时存在左右子结点，如下图所示：

![img](https://images2018.cnblogs.com/blog/1128337/201808/1128337-20180821005538601-1082714107.png)

　　从上图来看，如果删除结点5，会与情况2一样而违反性质，而对于右边的树，则不会，因为，我们删除的方式，是将z结点也就是结点5的左子树，连接到结点5右子树的值最小的结点上。然后用这个最小结点来替换原来结点z（也就是图上结点5的位置）。这样做的好处是，仍可以保证删除后的树仍满足BST树的性质，我们只需要对被删除结点的子树进行修改颜色性质就可以了，而且，不论最小结点的颜色如何，都不会导致出现两个红结点的情况。这一点可能很多人会存在疑惑，我们来分析一下：

　　对于左右子树都存在的的删除结点来说，此时，y从指向z转向了指向删除结点z的右子树种最小的一个结点（右子树的最左结点），这样的指向，无非两种情况，一种是右子树的最左结点就是被删除结点z的右孩子，即其右孩子的左孩子为NIL，这样，以上右图为例，y指向了结点6，然6后，用y_original_color来保存结点6的颜色，用x指向6的右孩子，由于在这里，y的父亲结点依旧为删除结点z，因此，设置好结点属性x.p = y，然后，执行替换操作（Transplant）来实现删除的目的，可以看到，transplant操作是对删除结点z和替换结点y进行操作的，对于这种情况来说，是将z与其右孩子进行替换，根据伪码，结点7的左孩子指向了结点6。然后结点6也就是现在的结点y的左孩子指向了结点z的左孩子，这样就完成了然后将结点y的颜色，改成结点z的颜色，为什么这么做呢，是为了保持与原来红黑树相同的特性，因为我们知道，在删除结点5之前，结点5左右两棵子树的一条路径上的黑色结点数目是相同的，但是，由于结点6的上位（替换了其父结点），而父结点的左孩子直接成为其左子树，这就导致了左右两子树的不平衡，调整为与z结点相同的颜色以后，可以使得对红黑树修改操作仅局限于结点y这棵子树中进行。

　　另一种情况则是右子树的最左结点不是被删除结点z的右孩子，即其右孩子的左孩子非空，那么，其余操作不变，比较巧妙的是，这里运用了最左结点的左孩子为NIL的特性，将最左结点的右子树接到了其父节点的左边（这就保证了BST树的有序性），且这样的做法，使得该结点与树在结构上断开，无法通过树的根结点访问到，因此，后续再执行一次删除结点z与结点y的替换操作，就可以完成这样的删除操作。这种情况下，会产生y为红色或者黑色结点的问题，同样，也只会有黑色会违背红黑树的性质。

#####  红黑树删除操作后的修改结点颜色操作

通过上面的分析，我们很容易得到这样的结论，那就是，只有当y为黑色结点的时候，才会发生违背红黑树性质的情况，因此，需要对这样的情况进行修改，来保持红黑树的性质。

![img](https://images2018.cnblogs.com/blog/1128337/201808/1128337-20180821110931242-2144250594.png)

在分析源码以前，我们首先来分析，执行删除操作以后，会出现哪些违背红黑树性质的情况。在这个操作中，结合删除操作的代码，我们可以发现，x始终指向具有双重黑色的非根结点。那么，就会有4种情况，这四种情况与插入操作中的是类似的，请读者结合上述删除操作，自行分析。　

 下面附上红黑树删除操作的代码。

```cpp
template<typename T>
void RedBlackTree<T>::Delete(RedBlackNode<T>* &t){
    /*
    *function to delete node t in redblacktree.
    *@Parameter:
    *t: a node need to be deleted.
    */
    RedBlackNode<T> *y;
    RedBlackNode<T> *p;
    y = t;
    string y_original_color = y->color;
    if(t->lchild==NIL){
        p = t->rchild;
        Transplant(t, t->rchild);
    }
    else if(t->rchild==NIL){
        p = t->lchild;
        Transplant(t, t->lchild);
    }
    else{
        y = TreeMinimum(t->rchild);
        y_original_color = y->color;
        p = y->rchild;
        if(Parent(y)!=t){
            Transplant(y, y->rchild);
            y->rchild = t->rchild;
        }
        Transplant(t, y);
        y->lchild = t->lchild;
        y->color = t->color;
    }

    if(y_original_color=="black"){
        RBDeleteFixup(p);
    }
    delete t;
    t = NULL;
}
```

红黑树删除后，修改颜色的操作代码。

```cpp
template<typename T>
RedBlackNode<T>* RedBlackTree<T>::TreeMinimum(RedBlackNode<T>* t){
    RedBlackNode<T> *p;
    while(t!=NIL){
        p = t;
        t = t->lchild;
    }
    return p;
}

template<typename T>
void RedBlackTree<T>::RBDeleteFixup(RedBlackNode<T>* &t){
    RedBlackNode<T> *p;
    RedBlackNode<T> *f;
    while(t!=NIL&&t->color=="black"){
        if(t==Parent(t)->lchild){
            p = Parent(t)->rchild;
            if(p->color=="red"){
                p->color = "black";
                Parent(t)->color = "red";
                f = Parent(t);
                LeftRotation(f);
                p = Parent(t)->rchild;
            }
            if(p->lchild->color=="black"&&p->rchild->color=="black"){
                p->color = "red";
                t = Parent(t);
            }
            else if(p->rchild->color=="black"){
                p->lchild->color = "black";
                p->color = "red";
                RightRotation(p);
                p = Parent(t)->rchild;
            }
            else{
                p->color = Parent(t)->color;
                Parent(t)->color = "black";
                p->rchild->color = "black";
                f = Parent(t);
                LeftRotation(f);
                t = root;
            }
        }
        else{
            p = Parent(t)->lchild;
            if(p->color=="red"){
                p->color = "black";
                Parent(t)->color = "red";
                f = Parent(t);
                RightRotation(f);
                p = Parent(t)->lchild;
            }
            if(p->rchild->color=="black"&&p->lchild->color=="black"){
                p->color = "red";
                t = Parent(t);
            }
            else if(p->lchild->color=="black"){
                p->rchild->color = "black";
                p->color = "red";
                LeftRotation(p);
                p = Parent(t)->lchild;
            }
            else{
                p->color = Parent(t)->color;
                Parent(t)->color = "black";
                p->lchild->color = "black";
                f = Parent(t);
                RightRotation(f);
                t = root;
            }
        }
    }
    t->color = "black";
}
```









### B-树



### B+树

B+ 树是一种树数据结构，是一个n叉树，每个节点通常有多个孩子，一棵B+树包含根节点、内部节点和叶子节点。根节点可能是一个叶子节点，也可能是一个包含两个或两个以上孩子节点的节点。

## B*树