## 参数的三种传递

参数有三种传递分别是值传递、指针传递和引用传递。
值传递是我们常见的传递方式，不管是在C#还是JAVA，都是有值传递的，C++也不例外，那么指针和引用则和值传递不同，不同之处呢，则是它们传递东西不同，都是都可以把一个值传给某个函数使用，它们不同之处我们通过一些例子来说明。

##### 1.值传递

```cpp
void test(int a) {
    a += 3;
    cout << “a的值：” << a << “\n”
    << “a的地址：” << &a << “\n”;
}
void main()
{
    int b = 10;
    test(b);
    cout << “b的值：” << b << “\n”
    << “b的地址：” << &b << “\n”;
}
```

值传递的参数是有自己的内存的，并且当b把自己的值传递进去之后，对b是没有影响的，那么值传递则是等于把b的值赋给了a等于进行了一个赋值操作这就是值传递。

##### 2.指针传递

```cpp
void test(int *a) {
    *a += 3;
    cout << “a所指向地址：” << a << “\n”
    << “a的地址：” << &a << “\n”
    << “a所指向地址的值：” << *a << “\n”;
}
void main()
{
    int b = 10;
    test(&b);
    cout << “b的值：” << b << “\n”
    << “b的地址：” << &b << “\n”;
}
```

这是一个指针传递，可以明显的发现和值传递的差别，指针是存储地址的，当我们想要把b的值传进test()函数时，我们传的是b的地址，然后通过b的地址，来获得b的值。

很明显的是这次输出的地址比值传递多一个地址，那这个多的地址和b的地址一模一样，可以说明的是指针传递的是地址，然后还有不同的是b的值也被改变了，这就指针传递和值传递的不同。

##### 3.引用传递

```cpp
void test(int &a) {
    a += 3;
    cout << “a的值：” << a << “\n”
    << “a的地址：” << &a << “\n”;
}
void main()
{
    int b = 10;
    test(b);
    cout << “b的值：” << b << “\n”
    << “b的地址：” << &b << “\n”;
}
```

在代码上是不是发现和值传递差不多，只是参数声明哪里比值传递的多了一个&符号其他的和值传递一样，但是就是在参数声明哪里多一个&符号，它就不是值传递，它的传递方式和值传递的是完全不一样的，所以在写参数声明时，要注意不要在你需要的引用传递时漏了一个&符号。

可以发现的是a的值和b的值是一样的，上面我们说指针传递时，是输出了一个a所指向地址的值，它的值和b的值是一样，那么引用是不是和指针一样传的地址呢，其实不是的因为引用传递其实是等于把b作为test()函数的全局变量，为什么这样说呢，是因为a的地址和b相同，然后a所做的所有操作都等于b做的，这a像是b的什么呢，这是名字不同，其他一样，a其实就是b的一个别名，所以test()函数对a的所有操作，都等于对b进行，而a只是b的另外一个标识。

##### 总结

总结一下值传递、指针传递和引用传递不同的地方，

首先它们都是可以把值传递给函数的只不过是传递的方式不同，有一点是可以很明显的，指针传递和引用传递都会改变b的值，值传递不会，这就是值传递和另外两个的区别，而指针传递和引用传递的不同的地方则是指针传递的是b的地址，而引用传递则等于给b起了一个别名，然后通过别名来操作b的值，和它所在的内存地址。

### 拷贝赋值函数的形参能否进行值传递

不能。如果是这种情况下，调用拷贝构造函数的时候，首先要将实参传递给形参，这个传递的时候又要调用拷贝构造函数。。如此循环，无法完成拷贝，栈也会满。

### 拷贝构造函数和拷贝赋值函数

拷贝构造函数是针对一个未存在的对象进行初始化；

拷贝赋值函数是针对已存在的对象进行初始化。

```cpp
A a;  
A b = a; //拷贝构造，b还没存在  
A c;  
b = c; //拷贝赋值，b已经存在
```

##### 拷贝构造函数

https://www.cnblogs.com/yuanfy/p/3899658.html

拷贝构造函数会将其参数的成员逐个拷贝到正在创建的类对象中。拷贝构造函数使类具有自行赋值本类对象的能力，也就是可生成一个对象的副本，它只以本类对象的引用作为其唯一的形参，该函数的定义形式如下：

class  类名
{
    public：
　　　　类名（形参）；//（构造函数）
　　　　类名（类名  &对象名）；//（拷贝构造函数）
　　　　　　..................
};

类名::类名（类名  &对象名）//拷贝构造函数的实现
{
　　函数体
}

```cpp
class Point
{
　　public:
　　　　Point(int xx=0,int yy=0)   //定义构造函数
      {
　　　　　　X=xx;
　　　　　　Y=yy;
　　　　}
　　　　Point(Point &p);   //声明拷贝构造函数
　　　　int GetX()  {return X;}
　　　　int GetY()  {return Y;}
　　private:
　　　　int X,Y;
};

Point::Point(Point &p)//定义拷贝构造函数
{
　　X=p.X;
　　Y=p.Y；
　　cout<<"拷贝构造函数被调用"<<endl;
}
```

拷贝构造函数被自动调用执行的三种情况：

1）当用类的一个对象去初始化该类的另一个对象时

2）若函数的形参为类对象，调用函数，实参赋值给形参时

3）若函数的返回值是类的对象，函数执行完成返回调用时

如果程序员没有为类声明拷贝初始化构造函数，则编译器自己生成一个拷贝构造函数。该函数的功能是：初始化将要建立的对象的对应的数据成员。

##### 浅拷贝

由默认的拷贝构造函数将已有的对象的数据成员 赋值给同类的新对象的各数据成员来构造新对象的方法就是浅拷贝，也即是成员级拷贝。

不足之处：

若用户未提供类的显示拷贝构造函数，而让系统去执行缺省的拷贝构造函数，只进行对象间的原样拷贝，从而使得两个不同对象的地址值完全相同，当对象被析构时，则会出现同一资源被释放了两次的错误。

```cpp
class A{
   int i;
};
class B{
   A *p;
public:
   B(){p=new A;}
   ~B(){delete p;}
};
void sayHello(B x){
}
int main(){
   B b;
   sayHello(b);
}
```

main函数里调用sayHello函数的时候，将b浅拷贝给了x，当sayHello函数执行完后，会调用析构函数释放掉p，而当main函数结束时，也会调用析构函数释放掉p，所以就会重复释放指针，导致程序崩溃。

##### 深拷贝

为了克服浅拷贝的不足，用户必须给出显式的拷贝构造函数，以实现“深拷贝”的功能：在拷贝构造函数中，首先要动态申请存储空间，并向该空间拷贝原对象的内容。

```cpp
person(person &p)
{
　　cout<<"copying"<<p.pName<<"into its own block"<<endl;
　　pName=new char[strlen(p.pName)+1];
   strcpy(pName,p.pName);
}
```

**总结：**浅拷贝就是指向同一个地址；深拷贝就是新开辟一个空间用于存储，也就是指向了两个不同的地址。