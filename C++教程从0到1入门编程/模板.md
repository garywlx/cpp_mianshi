## 模板

泛型编程——模板

模板就是简历通用的模具，大大提高复用性

模板不可以直接使用，它只是一个框架。

模板的通用并不是万能的。

模板有两种，一是函数模板，一是类模板

### 函数模板

函数模板作用：建立一个通用函数，其返回值类型和形参类型可以不具体制定，用一个虚拟的类型来代表。

```cpp
template<typename T>
void mySwap(T& a, T& b) {
    T temp = a;
    a = b;
    b = temp;
}

int main() {
    //有两种方式使用函数模板
    int a = 10, b = 20;
    //方式一，自动类型推导
    mySwap(a,b);
    
    double i = 10.0, j = 20.0;
    //方法二、显示指定类型
    mySwap<double>(i,j);
}
```

注意事项：

- 自动类型推导，必须推导出一致的数据类型T才可以使用
- 模板必须要确定出T的数据类型才可以使用

##### 普通函数和函数模板的区别

- 普通函数调用时可以发生自动类型转换(隐式类型转换)
- 函数模板调用时，如果利用自动类型推导，不会发生隐式类型转换
- 如果利用显示指定类型的方法，可以发生隐式类型转换

##### 普通函数和函数模板的调用规则

- 如果函数模板和普通函数都可以实现，优先调用普通函数
- 可以通过空模板参数列表来强制调用函数模板
- 函数模板也可以发生重载
- 如果函数模板可以产生更好的匹配，优先调用函数模板

```cpp
void myprint(int a, int b) {
    cout<<"普通函数"<<endl;
}
template<typename T>
void myprint(T a, T b) {
    cout<<"函数模板"<<endl;
}

int main() {
    int a = 10, b = 20;
    myprint(a,b);//调用普通函数
}
```

那如果普通函数只有void myprint(int a, int b);声明呢？

会报错，因为编译器会调用普通函数，然后发现没有定义，出错。

```cpp
void myprint(int a, int b) {
    cout<<"普通函数"<<endl;
}
template<typename T>
void myprint(T a, T b) {
    cout<<"函数模板"<<endl;
}
//函数模板也可以发生重载
template<typename T>
void myprint(T a, T b, T c) {
    cout<<"函数模板"<<endl;
}
int main() {
    int a = 10, b = 20;
    //通过空模板参数列表来强制调用函数模板
    myprint<>(a,b);//调用函数模板
    
    myprint(a,b,100);//调用重载的函数模板
    
    char c1 = 'a', c2 = 'b';
    myprint(c1,c2);//普通函数通过隐式类型转换调用，函数模板通过自动类型推导调用，这时候调用函数模板
    //因为如果函数模板可以产生更好的匹配，优先调用函数模板
}
```

##### 模板的局限性

模板的通用并不是万能的。

```cpp
//如果赋值操作中，传入的a和b是数组，就无法实现了。
template<typename T>
void f(T a, T b) {
    a = b;
}

//如果比较操作中，传入的T类型是类类型，也无法正确运行，
//解决方法之一是类中重载比较运算符，也是可以通过的
template<typename T>
bool f(T a, T b) {
    if(a > b) {...}
}
```

因此C++为了解决这种问题，通过了模板的重载，可以为这些特定的类型提供具体化的模板。

解决方法之一，对传入T类型是Person类的情况，就对函数进行重载。只要是Person类就做这条路。

```cpp
template<typename T>
bool f(T a, T b) {
    if(a > b) {...}
}
//利用具体化Person的版本实现代码，具体化优先调用
template<> bool f(Person& a, Person& b) {
    if(a > b) {...}
}
```

利用具体化模板，可以解决自定义类型(类类型)的通用化

学习模板并不是为了要写模板，而是在STL能够运用系统提供的模板

### 类模板

类模板作用：建立一个通用类，类中的成员数据类型可以不具体制定，用一个虚拟的类型来代表。

```cpp
template<typename N, typename A>
class Person {
public:
    Person(N name, A age):m_name(name),m_age(age){}
    N m_name;
    A m_age;
}
int main() {
    Person<string,int> p1("小孙",20);
    
}
```

类模板和函数模板语法相似，在声明模板template后面加类，此类称为类模板。

